;;http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-11.html#%_sec_1.2

;; Section 1.2.
;; 1.2 Procedures and the Processes They Generate

(define (+* a b)
  (if (= a 0)
      b
      (inc (+* (dec a) b))))

(define (+** a b)
  (if (= a 0)
      b
      (+** (dec a) (inc b))))

(define (inc x) (+ x 1))
(define (dec x) (- x 1))

;; Using the substitution model, illustrate the process
;; generated by each procedure in evaluating (+ 4 5).
;; Are these processes iterative or recursive?

"eval (+ 4 5):"
(+* 4 5) ; => sub +* with its body.
(inc (+* (dec 4) 5)) ; =>
(inc (+* 3 5)) ; =>
(inc (inc (+* (dec 3) 5))) ; =>
(inc (inc (+* 2 5))) ; =>
(inc (inc (inc (+* (dec 2) 5)))) ; =>
(inc (inc (inc (+* 1 5)))) ; =>
(inc (inc (inc (inc (+* (dec 1) 5))))) ; =>
(inc (inc (inc (inc (+* 0 5))))) ; =>
(inc (inc (inc (inc 5)))) ; =>
(inc (inc (inc 6))) ; =>
(inc (inc 7)) ; =>
(inc 8) ; =>
9

;; and the process is recursive.


;;
;; Exercise 1.10.
;; The following procedure computes a mathematical function
;; called Ackermann's function.

(define (A x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (A (- x 1)
                 (A x (- y 1))))))

;;What are the values of the following expressions?

(A 1 10)

(A 2 4)

(A 3 3)

;; Consider the following procedures,
;; where A is the procedure defined above:

(define (f n) (A 0 n))
;; (f n) =>
;; (A 0 n) =>
;; (* 2 n)
;; so we get:
;; (f n) = 2*n, (n >= 1)
;;       = 0,   (n = 0)

(define (g n) (A 1 n))
;; (g n) =>
;; (A 0 (A 1 (- n 1)))
;; (* 2 (A 1 (- n 1)))
;; (* 2 (A 0 (A 1 (- n 2))))
;; (* 2 (* 2 (A 1 (- n 2))))
;; (* 2 (* 2 (A 0 (A 1 (- n 3)))))
;; (* 2 (* 2 (* 2 (A 1 (- n 3)))))
;; ......
;; so we get:
;; (g n) = 2^n, (n >= 1)
;;         0,   (n = 0)

(define (h n) (A 2 n))
;; (h n) =>
;; (A 2 n) => ; when n > 1
;; (A 1 (A 2 (- n 1))) =>
;; (g (A 2 (-n 1))) =>
;; 2^(A 2 (- n 1)) =>
;; 2^(h (- n 1))
;; we get: (h n) => 2^(h (- n 1)), (n > 1)
;; so we get:
;; (h n) = 2^(2^(2^(...))), (n >= 1, n is number of 2)
;;       = 0, (n = 0)

(define (k n) (* 5 n n))

;; Give concise mathematical definitions for the functions computed
;; by the procedures f, g, and h for positive integer values of n.
;; For example, (k n) computes 5*n^2.
"2^2^2^2"
(h 4)

"2^2^2^2^2: "
;(h 5)


;; counting change:
(define (count-change amount)
  (cc amount 5))
(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))
(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 100)
;(count-change 500)

;;
;; Exercise 1.11.
;; (f n) = n, (n < 3)
;;       = (f (- n 1)) + 2*(f (- n 2)) + 3*(f (- n 3)), (n >= 3)

;; recursive procedure
(define (f n)
  (cond ((< n 3) n)
        (else ; n >=3
         (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3)))))))

"f rec: 10"
(f 10)

;; iterative procedure
;f(n)=f(n-1)+2f(n-2)+3f(n-3)
;f(n+1)=f(n)+2f(n-1)+3f(n-2)
;f(n)+f(n+1)=f(n)+3(f(n-1)+f(n-2)+f(n-3))
;f(n+1)=3(f(n-1)+f(n-2)+f(n-3))
;get:
;f(n)=3*(f(n-2)+f(n-3)+f(n-4)) ; n>=4
;we get:
;(a,b,c) =>
;(b,c,c+2*b+3*a)
;(0,1,2) => ...
(define (f-iter a b c n)
  (cond
    ((< n 0) n)
    ((= n 0) a) ; n < 3
    ((= n 1) b)
    ((= n 2) c)
    (else ; shif right.
     (f-iter b c (+ c (* 2 b) (* 3 a)) (- n 1)))))
(define (f n)
  (f-iter 0 1 2 n))

"f iter: 10"
(f 10)

;;
;; Exercise 1.12.
;; Pascal triangle.
; 1
; 1 1
; 1 2 1
; 1 3 3 1
; 1 4 6 4 1
; ....
; f(a,b)=f(a-1,b-1)+f(a-1,b)
; (f a b) => (+ (f (- a 1) (- b 1)) (f (- a 1) b))
(define (pascal-triangle n)
  (define (loop col)
    (cond ((> col n) (newline)) ; return
          (else
           (display (list (cell n col)))
           (loop (+ col 1)))))
  (define (cell row col)
    ;(display (list 888 row col))
    (cond
      ((and (= row 1) (= col 1)) 1)
      ((and (>= row 1) (<= row n)
            (>= col 1) (<= col n))
       (+ (cell (- row 1) (- col 1))
          (cell (- row 1) col)))
      (else 0)))
  (loop 1))

"1:"
(pascal-triangle 1)
"5:"
(pascal-triangle 5)
"50:"
(pascal-triangle 15)

;;
;; Exercise 1.13.
;; Prove that Fib(n) is the closest integer to FAI^n/sqrt(5),
;; where FAI = (1 + sqrt(5))/2.
;; Hint: Let UPS = (1 - sqrt(5))/2.
;; Use induction and the definition of the Fibonacci numbers
;; (see section 1.2.2) to prove that Fib(n) = (FAI^n - ups^n)/sqrt(5).
